<!DOCTYPE html>
<html lang="es">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <title>Angular</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">

  <!--ClipBoard-->
  <script src="node_modules/clipboard/dist/clipboard.min.js"></script>
</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/angular.jpg" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <dl class="navbar-nav">
        <dt class="nav-item"><a class="nav-link js-scroll-trigger" href="#quees">Introducción</a></dt>
          <dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#quees" >¿Que es Angular?</a></dd>
          <dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#Caracteristicas" >Caracteristicas</a></dd>
          <dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#TypeScript" >TypeScript</a></dd>
        <dt class="nav-item"><a class="nav-link js-scroll-trigger" href="#configuracion">Configuración</a></dt>
        <dt class="nav-item"><a class="nav-link js-scroll-trigger" href="#tour">Tour of Heroes</a></dt>
          <dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#crear">Crear nuestro proyecto</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#primeros">Primeros cambios</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#componenteheroe">Componente Heroe</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#listas">Crear listas</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#componentes">Componentes maestros</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#servicios">Servicios</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#enrutamiento">Enrutamiento</a></dd>
					<dd class="nav-item" style="font-size: 10px;"><a class="nav-link js-scroll-trigger" href="#http">HTTP</a></dd>
      </dl>
    </div>
  </nav>

  <div class="container-fluid p-0">
  <!--Que es-->
    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="quees">
      <div class="w-100">
        <h1 class="mb-0">¿Que es
          <span class="text-primary">Angular</span>
        ?</h1>
        <br/>
        <div class="subheading mb-5">
          <ul>
            <li>Angular es un framework de desarrollo para JavaScript creado por Google. ​</li>
            <li>La finalidad de este framework es facilitar el desarrollo de aplicaciones web SPA (Single Page Application). </li>
            <li>Ofrece herramientas para trabajar con los elementos de una web de una manera sencilla y óptima. ​</li>
            <li>Permite separar de forma completa el Front-end y el Back-end de la aplicación.​</li>
            <li>Las aplicaciones creadas en Angular pueden ser usadas en dispositivos móviles y de escritorio, usando el modelo vista controlador (MVC).</li>
            <li>El mayor peso de la ejecución es soportado por el lado del cliente, liberando así de peso al servidor.​</li>
          </ul>
        </div>
      </div>
    </section>
<!-- Caracteristicas e Historia-->
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex justify-content-center" id="Caracteristicas">
      <div class="w-100">
        <h2 class="text-primary">Caracteristicas y Historia</h2>

        <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <ul>
              <li><strong>Desarrollo movil: </strong>l desarrollo de aplicaciones de escritorio es mucho más fácil cuando primero se manejan los problemas de rendimiento en el desarrollo móvil.​</li>
              <li><strong>Modularidad: </strong> Para desarrollar una nueva funcionalidad esta se empaqueta en un módulo, produciendo un núcleo más ligero y más rápido.​</li>
              <li><strong>Compatibilidad: </strong>Es compatible con los navegadores más modernos y recientes.​</li>
            </ul>	
            <img  src="img/historia.png"  alt="" >
        </div>
        </div>
      </div>

    </section>
	<!-- TypeScript -->
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="TypeScript">
      <div class="w-100">
        <h2 class="text-primary">TypeScript</h2>
        <ul>
          <li>Lenguaje de código abierto desarrollado y mantenido por Microsoft.​</li>
          <li>Es un superconjunto de JavaScript, que esencialmente añade tipos estáticos y objetos basados en clases. ​</li>
          <li>Al extender JavaScript, cualquier código que funcione en dicho lenguaje, también lo haga en TypeScript.​</li>
          <li>Está pensado para grandes proyectos, ya que al “compilarse” genera archivos JavaScript minimizados.​</li>
          <li>Es un lenguaje multiplataforma.​</li>
          <li>Fue adoptado como lenguaje principal desde la versión 2.0 de Angular hasta la versión actual.​</li>
        </ul>			
      </div>
    </section>
<!-- Configuracion del entorno -->
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="configuracion">
      <div class="w-100">
        <h2 class="text-primary">Configuración del entorno</h2>
        <p >Antes de empezar a trabajar es necesario configurar nuestro espacio de tabaajo, para ello:</p>
        <ol>
          <li>Descargamos los componentes necesarios:
            <ol>
              <li>Descargamos e instalamos Node.js</li>
              <li>Comprobamos a través de consola si Node se instalo correctamente usando el comanod:</li>
            </ol>
            <br/>
              <pre><code id="target"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>node -v </code></pre>
            <ol type="1" start="3">
              <li>Comprobamos que al instalar Node se nos instalará el paquete npm con el comando: </li>
            </ol>
            <br/>
            <pre><code id="target2"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target2"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>npm -v</code></pre>
          </li>
          <li>Instalamos Angular CLI a través del comando: </li>
        </ol>
          <pre><code id="target1"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target1"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>npm install -g @angular/cli</code></pre>
        <ol type="1" start="3">
          <li>Creamos un espacio de trabajo con el nombre deseado usando el siguiente comando: </li>
        </ol>
          <pre><code id="target3"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target3"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng new nombre_de_la_aplicacion</code></pre>
        <ol type="1" start="4">
          <li>Ejecutamos nuestra aplicación</li>
        </ol>
          <pre><code id="target4"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target4"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>cd nombre_de_la_aplicacion 
       ng serve --open</code></pre>
        <p>Una vez ejecutado el último comando se nos abrirá automáticamente nuestra aplicación en el navegador. </p>
      </div>
    </section>
<!-- Tour of Heroes -->
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="tour">
      <div class="w-100">
        <h2 class="text-primary">Tour of Heroes</h2>
        <p>El objetivo de nuestro curso será el de construir una aplicación en la cuál iremos viendo paso a paso los principales componentes de Angular​.<br/>
          El resultado final de nuestra aplicación debería de ser algo parecido a la siguiente navegación: </p>
          <img src="img/aplicacion.png" alt="" id="aplicacion"> 
        </div>
    </section>
<!-- Creo nuestro proyecto -->
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="crear">
      <div class="w-100">
        <h2 class="text-primary">Crear nuestro proyecto</h2>
        <p >Con los comandos vistos anteriormente creamos nuestro nuevo proyecto con el nombre de angular-tour-of-heroes</p>
							<pre><code id="target5"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target5"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng new angular-tour-of-heroes</code></pre>
							<p>Abrimos el servidor de la aplicación usando el comando: </p>
							<pre><code id="target6"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target6"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng serve --open</code></pre>
							<p>Se ha de tener en cuenta que para ejecutar este comando debemos de estar en la consola dentro de la carpeta que contiene el proyecto</p>
							<p>Al crear la aplicación se nos generarán los componentes necesarios para la aplicación.<br/>
							Los <strong>componentes</strong> son bloques de construcción fundamentales de las aplicaciones Angular</p>
							<p>Los tres compoentes principales de la aplicación son:</p>
							<ul>
								<li>App.component.ts que contiene el código de la clase escrito en TypeScript</li>
								<li>App.component.html que contiene la plantilla del componente</li>
								<li>App.component.css que contiene los estilos provados del componente</li>
							</ul>
      </div>
    </section>

  <!-- Primeros cambios -->
  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="primeros">
    <div class="w-100">
      <h2 class="text-primary">Primeros cambios</h2>
      <ol>
        <li>Primeros cambios:
          <ol>
            <li>Cambiar el titulo de nuestra aplicación:
              <ul>
                <li>Abtimos el archivo <strong>App.component.ts</strong> y cambiamos el valor del titulo por el de "Tour of Heroes"</li>
                <li>Después nos vamos al archivo <strong>App.component.html</strong> y ponemos un titulo con el contenido de titulo:</li>
              </ul>
              <br/>
                <pre><code id="target7"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target7"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1&gt;{{title}}&lt;/h1&gt;</code></pre>	
              <ul>
                <li>Por ultimo para poder ver los heroes que se encuentran en nuestro compoente agregaremos la app de heroes:</li>
              </ul>
              <br/>
                <pre><code id="target8"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target8"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1&gt;{{title}}&lt;/h1&gt;
       &lt;app-heroes&gt;&lt;/app-heroes&gt;</code></pre>
              <ul>
                <li>Si el servidor esta aun activo, automanticamente le navegador deberia de recargarse y mostrar el titulo de la aplicación con el nombre del Heroe</li>
              </ul>
            </li>
            <li>Agregar estilos a la aplicación: 
              <ul>
                <li>Para ello nos vamos al archivo styles.css que creo el coponente CLI automanticamente al crear nuestro proyecto y agregamos el siguiente código: </li>
              </ul>
              <br/>
                <pre><code id="target9"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target9"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* Application-wide Styles */
        h1 {
        color: #369;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 250%;
        }
        h2, h3 {
        color: #444;
        font-family: Arial, Helvetica, sans-serif;
        font-weight: lighter;
        }
        body {
        margin: 2em;
        }
        body, input[type="text"], button {
        color: #333;
        font-family: Cambria, Georgia;
        }
        /* everywhere else */
        * {
        font-family: Arial, Helvetica, sans-serif;
        }</code></pre>
              
            </li>
          </ol>
        </li>
      </ol>
    </div>
  </section>

  <hr class="m-0">
<!-- Crear el componente heroe -->
  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="componenteheroe">
    <div class="w-100">
      <h2 class="text-primary">Crear el componente Heroe</h2>
      <p >En este punto nuestra aplicación tiene un titulo básico. Ahora vamos a crear un nuevo componente para mostrar información del héroe y colocar ese componente e</p>
							<ol>
								<li>Creamos el componente Hereos usando el siguiente comando: </li>
							</ol>
								<pre><code id="target10"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target10"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate component heroes</code></pre>
								<p>Esto nos generará una nueva carpeta que podremos encontrar en src/app/heroes y que contendrán tres archivos HeroesComponent junto con un archivo de prueba</p>
								<p>El HeroesComponent tendrá el siguiente aspecto: </p>
								<pre><code id="target11"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target11"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Component, OnInit } from '@angular/core'
        @Component({
          selector: 'app-heroes',
          templateUrl: './heroes.component.html',
          styleUrls: ['./heroes.component.css']
        })
        export class HeroesComponent implements OnInit {

          constructor() { }
                          
          ngOnInit() {
        }</code></pre>
									<p>Este archivo siempre importa el componente de la bibliteca central de Angular y añade la clase con el .@component</p>
									<p>El @component es una función decoradora que especifica los metadados angulares para el componente. El CLI generó tres propiedades de metadatos: </p>
									<ul>
										<li><strong>Selector -></strong> el selector de elementos CSS del componente</li>
										<li><strong>TemplateUrl -></strong> la ubacación del archivo de plantilla del componente </li>
										<li><strong>StyleUrls -></strong> la ubicación de los estilos CSS privados del componente</li>
									</ul>
									<p>El selector de elementos CSS , 'app-heroes', coincide con el nombre del elemento HTML que identifica este componente dentro de la plantilla de un componente de los padres.</p>
									<p>El ngOnInit()es un gancho de ciclo de vida . Realizada las llamadas de los componentes, por lo que es aquí donde se deben inicializar los componentes.</p>
									<ol type="1" start="2">
									<li>Agregar una propiedad Héroe:</li>
									</ol>
									<p>Vamos agregar una propiedad heroe demtro del heroes.component.ts para ella añadimos el siguiente código:</p>
									<pre><code id="target12"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target12"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>hero = "Windstorm";</code></pre>
									<ol type="1" start="3">
									<li>Mostrar el héroe: </li>
									</ol>
									<p>Ahora abriremos el heroes.component.html y sustituiremos el texto predeterminado por la propiedad héroe</p>
									<pre><code id="target13"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target13"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>{{hero}}</code></pre>
									<ol type="1" start="4">
									<li>Mostrar el componente Héreo en la vista:</li>
									</ol>
									<p>Para poder mostrar el componente Héreo debemos agregarlo a la plantilla App.Component </p>
									<p>Recuerda que el App-heroes es el selector de elementos para el HeroesComponent, por lo  tanto se debe agregar un &lt;app-heroes&gt; justo debajo del titulo</p>
									<pre><code id="target14"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target14"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1&gt;{{title}}&lt;/h1&gt;
       &lt;app-heroes&gt;&lt;/app-heroes&gt;</code></pre>
									<p>Llegados a este punto si el servidor esta levantado el navegador automanticamente actualizará la web y se mostrará tanto el titulo de la aplicación como el nombre del héroe.</p>
									<ol type="1" start="5">
									<li>Crear una clase Héroe: </li>
									</ol>
									<p>Ahora vamos a crear una clase Héroe y le vamos a añadir un id y un nombre. Para ello abrimos el archivo hero.ts y incluimos el siguiente código:  </p>
									<pre><code id="target15"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target15"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>export class Hero {
       id: number;
       name: string;
      }</code></pre>
									<p>Ahora regresamos a la clase del componente Heroe e importamos la clase Héroe. Dale valores al id y al nombre. Al final el resultado del archivo debería de ser algo parecido al siguiente códdigo:</p>
									<pre><code id="target16"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target16"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Component, OnInit } from '@angular core';
        import { Hero } from '../hero';
                            
        @Component({
          selector: 'app-heroes',
          templateUrl: './heroes.component.html',
          styleUrls: ['./heroes.component.css']
        })
        export class HeroesComponent implements OnInit {
          hero: Hero = {
          id: 1,
          name: 'Windstorm'
        };
                            
        constructor() { }
                            
        ngOnInit() {
        }
                            
        }</code></pre>
								 <p>Llegado a este punto verás que tu página ahora no carga bien, porque es necesario que mostremos el objeto Héroe, que veremos en el siguiente punto:</p>
								 <ol type="1" start="6">
								 <li>Mostrar los objetos:</li>
								 </ol>
								 <p>Para que el objeto se muestre en la página deberemos actualizar la plantilla por lo que abriremos el archivo heroes.component.html y actualizaremos el código al siguiente:</p>
								 <pre><code id="target17"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target17"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h2&gt;{{hero.name}} Details&lt;h2&gt; 
       &lt;div&gt;&lt;span&gt;id: &lt;span&gt;{{hero.id}}&lt;/div&gt; 
       &lt;div&gt;&lt;span&gt;name: &lt;span&gt;{{hero.name}}&lt;/div&gt;</code></pre>
								 <p>Si queremos que el nombre del Héreo salga formateado en mayusculas usaremos las tuverias (|) para formatearlo con el UpperCase.<br/>Las canalizaciones son una buena forma de formatear cademas de texto, fechas, importes de menoda etc de forma sentilla y rápida</p>
								 <pre><code id="target18"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target18"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h2&gt;{{hero.name | uppercase}} Details&lt;h2&gt; </code></pre>
								 <ol type="1" start="7">
								 <li>Editar el héroe:</li>
								 </ol>
								 <p>Lo siguiente que queremos hacer es que el héreo sea editable para los usuarios de nuestra aplicación. El objetivo es que la propiedad nombre se cambie conforme el usuario vaya escribien el nuevo nombre en la opción de editar, para ello necesitaremos construir un enlace de datos bidimensional entre el input del formulario y la propiedad nombre del héreo. <br/>Para ello deberemos irnos al archivo heroes.component.html y cambiar el área de los detalles por el siguiente código:</p>
								 <pre><code id="target19"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target19"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div>
      &lt;label>name:
        &lt;input [(ngModel)]="hero.name" placeholder="name"/>
      &lt;label>
    &lt;div></code></pre>
							<p>El ngModel es la sintaxis que usa Angular para el enlace de datos. De esta forma vincula la propiedad nombre del héroe al cuadro HTML para que los datos puedan fluir en ambas direcciones.<br/>Si intentamos ahora actualizar la página veremos que no funciona, esto es por que es necesaria agregar el módulo ya qye aunque Angular incorporá esto no la trae activa por defecto, para ello necesitaremos importar el módulo.<br/>Cuando creamos el proyecto la herramienta CLI nos genero un archivo llamado <strong>app.module.ts</strong>, este archivo contiene los módulos implementados en nuestra aplicación, por lo que abriremos este archivo e incorporaremos la siguiente sentencia al código:</p>
							<pre><code id="target20"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target20"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { FormsModule } from '@angular/forms'; // &lt;-- NgModel lives here</code></pre>	
							<p>Luego tendremos que agregar el FormsModule en la matriz de datos, para ello una la parte de imports añadiremos lo siguiente: </p>
							<pre><code id="target21"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target21"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>imports: [
        BrowserModule,
        FormsModule
      ],</code></pre>
							<p>Ahora es hora de probar como al editar el nombre del héroe se actualiza al mismo tiempo la propiedad nombre.<br/><br/>Por último debemos de tener en cuenta lo siguiente, todo componente debe estar declarado en el NgModule, y aunque nosotros no lo hemos hecho la aplicación a funcionado correctamente, esto se debe a que la herramienta CLI declaró el componente Héroe en AppModele cuando se generó el componente, es hora de abrir el archivo app.module.ts y veremos el componente Héroe importado en la parte superior del archivo y Después encontraremos en las declaraciones el HeroesComponent.</p>
    </div>
  </section>

  <hr class="m-0">
<!-- Crear listas -->
  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="listas">
    <div class="w-100">
      <h2 class="text-primary">Crear listas</h2>
      <p>En este punto crearemos una lista de héroes y permitirá a los usuarios seleccionar un héroe y mostrar los detalles sobre él</p>
      <ol>
        <li>Crear una lista de héroes:</li>
      </ol>
        <p>Lo primero que vamos a hacer es simular una lista de héroes, normalmente recibiriamos estos datos de un servidor remoto, pero para probar a hacer listas nosotros solo lo simularemos. <br/>Así que crearemos un archivo llamado mock-heroes.ts dentro de la carpeta <strong>src/app</strong> y crea como unos diez héroes aproximadaente como mostramos en el siguiente ejemplo</p>
        <pre><code id="target22"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target22"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Hero } from './hero';
      export const HEROES: Hero[] = [
      { id: 11, name: 'Dr Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
      ];</code></pre>
      <ol type="1" start="2">
      <li>Mostrar los héreos de la lista:</li>
      </ol>
      <p>Ahora deberemos de abrir el archivo heroes.component.ts y importaremos la lista que hemos simulado</p>
      <pre><code id="target23"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target23"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>export class HeroesComponent implements OnInit {
        heroes = HEROES;
       }</code></pre>
      <ol type="1" start="3">
      <li>Usar el componente ngFor para mostrar las listas:</li>
      </ol>
      <p>Ahora nos iremos al heroes.component.html y deberemos de añadir el código necesario para mostrar la lista<br/>Primero veremos la parte sencilla, que sería mostrar a un único héroe, el código sería el siguiente:</p>
      <pre><code id="target24"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target24"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h2>My Heroes&lt;h2>
      &lt;ul class="heroes">
      &lt;li>
      &lt;span class="badge">{{hero.id}}&lt;span> {{hero.name}}
      &lt;li>
      &lt;ul></code></pre>
      <p>Si queremos mostrar todos los héreos deberemos de modificar la siguiente linea de código:</p>
      <pre><code id="target25"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target25"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;li *ngFor="let hero of heroes">&lt;li></code></pre>
      <ol type="1" start="4">
      <li>Darle estilo a la lista de héroes:</li>
      </ol>
      <p>Como todas las cosas, con belleza y buen CSS es más fácil de ver, por ello llegados a este punto le daremos un estilo a las listas para que se vean bonitas y entren por los ojos. <br/>Para ello en primer lugar nos heremos al archivo heroes.component.css y añadimos el siguiente código:</p>
      <pre><code id="target26"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target26"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* HeroesComponent's private CSS styles */
      .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
      }
      .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
      }
      .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
      }
      .heroes li.selected {
      background-color: #CFD8DC;
      color: white;
      }
      .heroes li.selected:hover {
      background-color: #BBD8DC;
      color: white;
      }
      .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color:#405061;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
      }</code></pre>
      <ol type="1" start="5">
      <li>Agregar el evento para ver los detalles del héroe:</li>
      </ol>
      <p>Ahora vamos a gregar el evento de raton al hacerl click para ver los detalles del héroe. Para ello deberemos modificar la siguiente linea del código dentro del archivo heroes.component.html </p>
      <pre><code id="target27"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target27"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;li *ngFor="let hero of heroes" (click)="onSelect(hero)">&lt;li></code></pre>
      <p>Los parentesis del click es el encargado de decirle a Angular que debe escuchar el evento, cuando el usuario hace click sobre el &lt;li> se ejecuta el onSelect<br/>Por tanto lo siguiente que debemos hacer es definir el método onSelect para ello nos iremos al archivo heroes.component.ts y agregaremos las siguientes lineas al código:</p>
      <pre><code id="target28"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target28"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>selectedHero: Hero;
        onSelect(hero: Hero): void {
        this.selectedHero = hero;
      }</code></pre>
      <p>Ahora necesitaremos añadir un sección que sea la de detalles para ello nos iremos al archivo heroes.component.html y modificaremos el código para que quede de la siguiente manera: </p>
      <pre><code id="target29"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target29"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h2>{{selectedHero.name | uppercase}} Details&lt;h2>
      &lt;div>&lt;span>id: &lt;span>{{selectedHero.id}}&lt;div>
      &lt;div>
      &lt;label>name:
      &lt;input [(ngModel)]="selectedHero.name" placeholder="name"/>
      &lt;label>
      &lt;div></code></pre>
      <p>¿Qué pasará ahora si recargas la página? Efectivamente, la página se rompe y no carga ¿Por qué? Pues por el simple hecho de que al cargar la página no hay nigún héroe seleccionado, por lo tanto el valor no existe y no sabe que debe de mostrar.<br/>¿La solución? Vamos a añadir la directiva ngIf para que los detalles no se muestren si no hay detalles como mostrar. Para ello modificaremos el código:</p>
      <pre><code id="target30"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target30"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div *ngIf="selectedHero">

      &lt;h2>{{selectedHero.name | uppercase}} Details&lt;/h2>
      &lt;div>&lt;span>id: &lt;span>{{selectedHero.id}}&lt;div>
      &lt;div>
      &lt;label>name:
      &lt;input [(ngModel)]="selectedHero.name" placeholder="name"/>
      &lt;label>
      &lt;div>
              
      &lt;div></code></pre>
      <ol type="1" start="6">
      <li>Dar estilo al héroe seleccionado:</li>
      </ol>
      <p>Para ello modificamos en el HTML la siguiente parte del código, no nos hará falta modificar el CSS por que ya incluimos el estilo para los selected anteriormente</p>
      <pre><code id="target31"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target31"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;li *ngFor="let heroof heroes"
      [class.selected]="hero === selectedHero"
      (click)="onSelect(hero)">
      &lt;span class="badge">{{hero.id}}&lt;span> {{hero.name}}
      &lt;li></code></pre>
    </div>
  </section>

<!-- Componentes maestros -->
  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="componentes">
    <div class="w-100">
      <h2 class="text-primary">Componentes maestros</h2>
      <p>De momento en nuestra aplicacion el componente Héroes muestra tanto la lista de héroes como sus detalles, pero siendo realistas en una aplicaciíon grende no sería optimo que un componente fuera demasiado grande, sino que sería mejor dividirlo en subcomponente, donde cada componente estuviera enfocado a una tarea o flujo de trabajo especifico. <br/> Por eso, ahora vamos a dividir las tareas de nuestro componente, por lo tanto la opción de los detalleas la colocaremos en un nuevo componente que crearemos usando el comando: </p>
      <pre><code id="target32"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target32"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate component hero-detail</code></pre>
      <p>Este archivo nos creará la carpeta /src/app/hero-detael con 4 archivos dentro, el CSS, el HTML, el .TS y un archivo de prueba para la clase<br/>Ahora abre tu HeroesComponent.html y corta el siguiente trozo de código y pegalo en el Heroes-detail.component.html</p>
      <pre><code id="target33"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target33"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div *ngIf="hero">

      &lt;h2>{{hero.name | uppercase}} Details&lt;h2>
      &lt;div>&lt;span>id: &lt;span>{{hero.id}}&lt;/div>
      &lt;div>
      &lt;label>name:
      &lt;input [(ngModel)]="hero.name" placeholder="name"/>
      &lt;label>
      &lt;div>
              
      &lt;div></code></pre>
      <ol>
        <li>Agregar el input a la propiedad Héroe y mostrarlo:</li>
      </ol>
        <p>Ahora ambas plantillas se unen puesto que ambas son de tipo Hero. Por ello necesitamos abrir el hero-detail.component.ts e importarlo</p>
        <pre><code id="target34"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target34"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Hero } from '../hero';</code></pre>
        <p>Ahora la propiedad Hero debe de convertirse en una propiedad de entrada, anotada con un decorador, porque el externo se unira a ella a través del input. Para ello añade los siguientes códigos. <br/>Al final del heroes.component.htm</p>
        <pre><code id="target35"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target35"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;app-hero-detail [hero]="selectedHero">&lt;app-hero-detail></code></pre>
        <p>hero-detail.component.ts importa em la parte superior:</p>
        <pre><code id="target36"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target36"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Component, OnInit, Input } from '@angular/core';</code></pre>
        <p>Y por último en el mismo archivo, añada debajo del export class el siguiente código:</p>
        <pre><code id="target37"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target37"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>@Input() hero: Hero;</code></pre>
    </div>
  </section>
<!-- Servicios -->
  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="servicios">
    <div class="w-100">
      <h2 class="text-primary">Servicios</h2>
      <p>Ahora mismo nuestra aplicación esta obteniendo y mostrando datos "falsos". Entonces, ¿porque añadirles servicios?<br/>Añadiendo servicios a la aplicación los componentes no deberán buscar ni guardar datos directamente sino que delegarán al servicio ese trabajo. Ahora vamos a crear un servicio que será usado por todas las clases <br/> Los servicios son una excelente manera de compartir información entre clases que no se conocen entre sí . Por eso crearemos un MessageServicee y lo inyectaremos en dos lugares:</p>
      <ul>
        <li>En el HeroServiceque utiliza el servicio para enviar un mensaje</li>
        <li>En el MessagesComponentque muestra ese mensaje</li>
      </ul>
    <ol>
      <li>Crear el HeroService:</li>
    </ol>
      <p>Usamos el siguiente comando para generar el servicio:</p>
      <pre><code id="target38"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target38"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate service hero</code></pre>
      <p>Este comando nos generará un esqueleto en la clase servicio en el archivo <strong>src/app/hero.service.ts</strong><br/>Si observas el archivo verás que se inporta el sercio <strong>@Injectable</strong>. Es un simbolo de Angular y usa decoradores para la clase. Esta clase proporciona ahora un servicio inyectable y también puede tener sus propies dependencias inyectadas.</p>
    <ol type="1" start="2">
      <li>Obtener datos del héroe:</li>
    </ol>
    <p>Ahora el servicio es capaz de obtener datos desde cualquier lugar, ya sea desde un servicio web, local o una fuente de datos simulada. Nosotros seguiremos usando héroes simulados<br/>En primer lugar abriremos el archivo <strong>hero.service.ts</strong> e importaremos el servicio incluyendo el siguiente código:</p>
    <pre><code id="target39"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target39"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Hero } from './hero';
      import { HEROES } from './mock-heroes';
      <strong style="text-transform: uppercase;">Agrega abajo el siguiente método para devolver los héroes simulados:</strong>
      getHeroes(): Hero[] {
      return HEROES;
      }</code></pre>
  <ol type="1" start="3">
    <li>Proporcionar el HeroService:</li>
  </ol>
  <p>Ahora debemos poner a disposición del sistema de inyección de dependencias el HeroService. Para que Angular pueda inyectarlo necesita un proveedor. ¿Qué significa esto? ¿Qie es un proveedor? Un <strong> proveedor</strong> es algo que peude crear o prestar un servicio, en este caso crea una instancia de la clase de HeroService para proporcionar el servicio.<br/>De manera predeterminada el comando Angular CLI ng generate service registra un proveedor con el inyector raíz para su servicio al incluir metadatos del proveedor.</p>
  <ol type="1" start="4">
    <li>Actulizar el compoente Héroe:</li>
  </ol>
  <p>Abiremos el archivo de clase Heroes.component.ts, eliminamos la importación que hicimos anteriormente por que ya no la necesitaremos</p>
  <pre><code id="target40"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target40"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { HeroService } from '../hero.service';</code></pre>
  <p>Y en su lugar inserte la siguiente linea de código:</p>
  <pre><code id="target126"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target126"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>heroes: Hero[];</code></pre>
  <ol type="1" start="5">
    <li>Inyectar el HeroService:</li>
  </ol>
  <p>Ahora debemos agregar un parámetro privado de tipo al constructor en el mismos archivo:</p>
  <pre><code id="target41"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target41"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>constructor(private heroService: HeroService) { }</code></pre>
  <p>Este parámetro define simultáneamente una propiedad privada y la identifica como un sitio de inyección<br/>Angular crea un sistema del insercción de dependencias que establece el parámetro en la instancia</p>
  <ol type="1" start="6">
    <li>Añadir getHeroes():</li>
  </ol>
  <p>Crearemos una función para recuperar los héroes del servicio:</p>
  <pre><code id="target42"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target42"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes(): void {
        this.heroes = this.heroService.getHeroes();
      }</code></pre>
  <ol type="1" start="7">
    <li>Llamarlo con ngOnInit():</li>
  </ol>
  <p>Aunque podriamos llamar al constructor no es una praáctica recomendada por lo que en su lugar vamos a usar ngOnInit que se encargará de llamar al constructor en el momento adecuado para ello dentro del archivo heros.component.ts incorporaremos el siguiente código:</p>
  <pre><code id="target43"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target43"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ngOnInit() {
         this.getHeroes();
       }</code></pre>
  <p>Ahora mismo nuestra aplicación funciona, pero en una aplicación real no funcionaría, funciona por que nuestro servicio esta devolviendo héroes simulados pero si tuviera que recuperarlos de un servidor remoto esto no funcionaria.</p>
  <ol type="1" start="8">
    <li>Agregar el observable HeroService:</li>
  </ol>
  <p>La clase Observable es una clase clave en la biblioteca RxJS, en el futuro veremos que a través del HttpClient devolvera observables de RxJS aunque en realidad en esta parte de la aplicación solo simulará obtenerlos con la función Of()<br/>Para ello vamos a abrir el archivo <strong>hero.service.ts</strong> y añadiremos la siguiente linea de código: </p>
  <pre><code id="target44"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target44"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Observable, of } from 'rxjs';</code></pre>
  <p>Ahora reemplaza el método getHeroes() por el siguiente método:</p>
  <pre><code id="target45"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target45"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes(): Observable&lt;Hero[]> {
        return of(HEROES);
      }</code></pre>
  <p>OfHeroes() devuelve un Observable que emite un único valor que seá el conjunto de los héroes simulados.</p>
  <ol type="1" start="9">
    <li>Suscribirse en el HeroesComponent:</li>
  </ol>
  <p>El método HeroService.getHeroes se usa para devolver una colección de Héroes. Ahora devuelve un Observable por eso debemos adaptar la diferencia en el HeroesComponent<br/>Ahora debemos encontrar el método getHeroes() y reemplazarlo con el siguiente código: </p>
  <pre><code id="target46"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target46"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes(): void {
        this.heroService.getHeroes()
            .subscribe(heroes => this.heroes = heroes);
      }</code></pre>
  <p>La versión anterior asignaba una veriedad de héroes a la propiedad heroes del componente. La asignación se producia sincrónicamente, pero eso no funcionará cuando el HeroService realmente esté haciendo solicitudes de un servidor remoto. La nueva versión espera a Ovservable que emita la matriz de héroes. El método subscribe() pasa la matriz emitida y establece la propiedad del componente. Esto si funcionará cuando el HeroService trabaje con un servidor. </p>
  <ol type="1" start="10">
    <li>Mostrar mensajes:</li>
  </ol>
  <p>En esta sección usaremos la herramienta CLI para generar un componente Mensaje para mostrar los mensajes de la aplicación, para ello creará un inyectable para enviar los mensajes que se mostrarán cuando el HeroService busque héroes con existo, para ello seguiremos los siguientes pasos:</p>
  <ol type="I" start="1">
    <li>Crear el componente Messages:</li>
  </ol>
  <p>Para ello desde la consola de Angular ejecutaremos el siguiente comando:</p>
  <pre><code id="target47"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target47"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate component messages</code></pre>
  <p>La herramienta CLI crea los archivos de componente en la carpeta y la declara en <strong>src/app/messagesMessagesComponentAppModule</strong><br/>Ahora modificaremos el archivo app.component.html para mostrar el mensaje generado:</p>
  <pre><code id="target48"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target48"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1>{{title}}&lt;h1>
    &lt;app-heroes>&lt;app-heroes>
    &lt;app-messages>&lt;app-messages></code></pre>
  <ol type="I" start="2">
    <li>Crear el MessageService:</li>
  </ol>
  <p>Para crear el MessageService utulizaremos la terminal para a través de la CLI crearlo:</p>
  <pre><code id="target49"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target49"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate service message</code></pre>
  <p>Ahora abriremos el message.service.ts y añadiremos el siguiente contenido:</p>
  <pre><code id="target50"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target50"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Injectable } from '@angular/core';

    @Injectable({
      providedIn: 'root',
    })
    export class MessageService {
      messages: string[] = [];
    
      add(message: string) {
        this.messages.push(message);
      }
    
      clear() {
        this.messages = [];
      }
    }</code></pre>
  <ol type="I" start="3">
    <li>Inyectarlo en el HeroService:</li>
  </ol>   
  <p>En primer lugar importaremos en el archivo hero.service.ts la siguiente linea de código:</p>
  <pre><code id="target51"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target51"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { MessageService } from './message.service';</code></pre>
  <p>Ahora modificaremos el constructor con un parámetro que declare un messageService con una propiedad privada. Angular inyectará el mensaje en esa propiedad cuando cree el HeroService:</p>
  <pre><code id="target52"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target52"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>constructor(private messageService: MessageService) { }</code></pre>
  <ol type="I" start="4">
    <li>Enviar un mensaje desde el HeroService:</li>
  </ol>
  <p>Modificamos el método getHeroes() para enviar un mensaje cuando se busquen los heroes. Dentro del archivo hero.service.ts incorpora las siguientes lineas de código:</p>
  <pre><code id="target53"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target53"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes(): Observable&lt;Hero[]> {
    // TODO: send the message _after_ fetching the heroes
    this.messageService.add('HeroService: fetched heroes');
    return of(HEROES);
  }</code></pre>
  <ol type="I" start="5">
    <li>Mostrar el mensaje desde el HeroService:</li>
  </ol>
  <p>El MessagesComponent debe mostrar todos los mensajes, incluyendo el mensaje enviado por el HeroService cuando se obtienen héroes.<br/>Ahora abrimos MessagesComponente y importaremos el MessageService. (messages.component.ts)</p>
  <pre><code id="target54"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target54"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { MessageService } from '../message.service';</code></pre>
  <p>También debemos modificar el constructar con un parámetro que declare una propiedad <strong>pública</strong>. Angular inyectará el mensaje en esa propiedad cuando cree el HeroService: </p>
  <pre><code id="target55"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target55"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>constructor(public messageService: MessageService) {}</code></pre>
  <p>La pripiedad debe ser pública por que la vincularemos con la pantalla.</p>
  <ol type="I" start="6">
    <li>Enlacazar al MessageService:</li>
  </ol>
  <p>Ahora abriremos el archivo messages.component.html y reemplazaremos el código existente por el siguiente código:</p>
  <pre><code id="target56"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target56"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div *ngIf="messageService.messages.length">

    &lt;h2>Messages&lt;h2>
    &lt;button class="clear"
            (click)="messageService.clear()">clear&lt;button>
    &lt;div *ngFor='let message of messageService.messages'> {{message}} &lt;div>
  
&lt;div></code></pre>
<p>Esta plantilla se une directamente a los componente messageService</p>
<ul>
  <li>Sólo muestra el área de mensajes si hay mensajes para mostrar (*ngIF)</li>
  <li>Presenta la lista de mensajes en elementos repetidos (*ngFor)</li>
  <li>Los enlace de eventos de Angular enlazan los eventos del click del botón MessageService.clear()</li>
</ul>
<p>Ahora sólo nos queda agregar el CSS del componente menssages para que se vean bien, para ello abriremos el archivo <strong>mesagges.component.css</strong> y agrege el siguiente código:</p>
<pre><code id="target57"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target57"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* MessagesComponent's private CSS styles */
      h2 {
        color: red;
        font-family: Arial, Helvetica, sans-serif;
        font-weight: lighter;
      }
      body {
        margin: 2em;
      }
      body, input[text], button {
        color: crimson;
        font-family: Cambria, Georgia;
      }
      
      button.clear {
        font-family: Arial;
        background-color: #eee;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        cursor: hand;
      }
      button:hover {
        background-color: #cfd8dc;
      }
      button:disabled {
        background-color: #eee;
        color: #aaa;
        cursor: auto;
      }
      button.clear {
        color: #333;
        margin-bottom: 12px;
      }</code></pre>
    </div>
  </section>

  <!-- Enrutamiento -->
  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="enrutamiento">
    <div class="w-100">
      <h2 class="text-primary">Enrutamiento</h2>
     <p>Llegados a este punto vamos a agregar nuevos requisitos a nuestra aplicación, esos requisitos serán los siguientes:</p>
     <ul>
       <li>Agregar un panel de control</li>
       <li>Agregar la capacidad de navegar entre las vistas Héroes y Panel de control</li>
       <li>Poder ver los detalles del Héroe desde cualquier pantalla</li>
     </ul>
     <p>Como mostramos al principio de este tutorial el resultado final será algo parecido a lo siguiente:</p>
     <img src="img/aplicacion.png" alt=""> <br/><br/>
      <h3 style="color: lightskyblue">Agregar el AppRoutingModule:</h3>
     <p>En Angular, la mejor práctica es cargar y configurar el enrutador en un módulo separado de nivel superior dedicado al enrutamiento e importado por la raíz AppModule.
     Por convención, el nombre de la clase del módulo es AppRoutingModule y pertenece al app-routing.module.ts en la carpeta src/app.<br/>Usa la CLI para generarlo.</p>
     <pre><code id="target58"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target58"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate module app-routing --flat --module=app</code></pre>
     <p>Se nos abrá generado un archivo llamado app-routing.module.ts, borrá su contenido y reemplácelo por el siguiente:</p>
     <pre><code id="target59"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target59"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { NgModule } from '@angular/core';
      import { RouterModule, Routes } from '@angular/router';
      import { HeroesComponent } from './heroes/heroes.component';
      
      const routes: Routes = [
        { path: 'heroes', component: HeroesComponent }
      ];
      
      @NgModule({
        imports: [RouterModule.forRoot(routes)],
        exports: [RouterModule]
      })
      export class AppRoutingModule { }</code></pre>
    <p>Ahora en las siguientes secciones se explicará los componentes de AppRoutingModule con más detalle</p>
    <ol type="1" start="1">
      <li>Rutas:</li>
   </ol>
   <pre><code id="target60"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target60"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>const routes: Routes = [
    { path: 'heroes', component: HeroesComponent }
  ];</code></pre>
  <p>Este trozo de código es donde se condiguran las rutas. Las rutas indican al enrutados que vistas debe mostrar cuando el usuario hace click en un enlace. En Angular el Route tiene dos propiedades principales:</p>
  <ul>
    <li><strong>Path:</strong> una cadena que coincide con la URL en la barra de direcciones del navegador</li>
    <li><strong>Component:</strong> el componente que el enrutador debe crear al navegar a esa ruta</li>
  </ul>
  <ol type="1" start="2">
    <li>RouteModule.forRoot():</li>
 </ol>
 <pre><code id="target61"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target61"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>imports: [ RouterModule.forRoot(routes) ],</code></pre>
 <p>Los metadatos inicializan el enrutador y escuchan los cambios de ubicación del navegador <br/>La linea que vimos anteriormente agrega la matriz y la configura en un solo paso llmando RouteModule.forRoot()<br/>Se llama al método forRoot() porque configura el enrutador en el nivel raíz de la aplicación. El método forRoot() proporciona los proveedores de servicios y las directivas necesarias para el enrutamiento, y realiza la navegación inicial en función de la URL actual del navegador.<br/>Por eso lo modificaremos para que este disponible para toda la aplicación:</p>
 <pre><code id="target62"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target62"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>exports: [ RouterModule ]</code></pre>
 <ol type="1" start="3">
  <li>Agregar RouterOutlet:</li>
</ol>
<p>Abre el archivo app.component.html y reemplace el &lt;app-heroes> por el elemento &lt;router-outlet></p>
<pre><code id="target63"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target63"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1>{{title}}&lt;h1>
&lt;router-outlet>&lt;router-outlet>
&lt;app-messages>&lt;app-messages></code></pre>
<p>La plantilla ya no necesita el app-heroes por que la aplicación sólo mostrará HeroesComponent cuando el usuario navega a ella.<br/>Ahora es hora de problarlo, desde la consola ejecuta el comando:</p>
<pre><code id="target64"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target64"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng serve</code></pre>
<p>Cuando se recargue tu página verás que ahora la barra de direcciones termina en /. Para poder acceder al HeroesComponent deberas poner /heroes</p>
<ol type="1" start="4">
  <li>Agregar un enlace de navegación ( routerLink):</li>
</ol>
<p>Idealmente, los usuarios deberían poder hacer clic en un enlace para navegar en lugar de pegar una URL en la barra de direcciones. Agrega un elemento &lt;nav> y, dentro de eso, un elemento de anclaje que, al hacer clic, active la navegación hacia HeroesComponent. La plantilla AppComponent revisada se ve así:</p>
<pre><code id="target65"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target65"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1>{{title}}&lt;h1>
    &lt;nav>
      &lt;a routerLink="/heroes">Heroes&lt;a>
    &lt;nav>
    &lt;router-outlet>&lt;router-outlet>
    &lt;app-messages>&lt;app-messages></code></pre>
<ol type="1" start="5">
  <li>Agregar una vista del tablero:</li>
</ol>
<p>El enrutamiento tiene más sentido cuando hay múltiples vistas. Por eso vamos a agregar un nuevo componente. A través de la consola ejecute el comando:</p>
<pre><code id="target66"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target66"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate component dashboard</code></pre>
<p>Ahora reemplaza el contenido de los soguientes archivos:</p>
<ul>
  <li>dashboard.component.html</li>
</ul>
<pre><code id="target67"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target67"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h3>Top Heroes&lt;h3>
      &lt;div class="grid grid-pad">
        &lt;a *ngFor="let hero of heroes" class="col-1-4">
          &lt;div class="module hero">
            &lt;h4>{{hero.name}}&lt;h4>
          &lt;div>
        &lt;a>
      &lt;div></code></pre>
<ul>
  <li>dashboard.component.ts</li>
</ul>
<pre><code id="target68"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target68"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>
  import { Component, OnInit } from '@angular/core';
  import { Hero } from '../hero';
  import { HeroService } from '../hero.service';
  
  @Component({
    selector: 'app-dashboard',
    templateUrl: './dashboard.component.html',
    styleUrls: [ './dashboard.component.css' ]
  })
  export class DashboardComponent implements OnInit {
    heroes: Hero[] = [];
  
    constructor(private heroService: HeroService) { }
  
    ngOnInit() {
      this.getHeroes();
    }
  
    getHeroes(): void {
      this.heroService.getHeroes()
        .subscribe(heroes => this.heroes = heroes.slice(1, 5));
    }
  }</code></pre>
  <ul>
    <li>dashboard.component.css</li>
  </ul>
  <pre><code id="target69"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target69"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* DashboardComponent's private CSS styles */
    [class*='col-'] {
      float: left;
      padding-right: 20px;
      padding-bottom: 20px;
    }
    [class*='col-']:last-of-type {
      padding-right: 0;
    }
    a {
      text-decoration: none;
    }
    *, *:after, *:before {
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    h3 {
      text-align: center;
      margin-bottom: 0;
    }
    h4 {
      position: relative;
    }
    .grid {
      margin: 0;
    }
    .col-1-4 {
      width: 25%;
    }
    .module {
      padding: 20px;
      text-align: center;
      color: #eee;
      max-height: 120px;
      min-width: 120px;
      background-color: #3f525c;
      border-radius: 2px;
    }
    .module:hover {
      background-color: #eee;
      cursor: pointer;
      color: #607d8b;
    }
    .grid-pad {
      padding: 10px 0;
    }
    .grid-pad > [class*='col-']:last-of-type {
      padding-right: 20px;
    }
    @media (max-width: 600px) {
      .module {
        font-size: 10px;
        max-height: 75px; }
    }
    @media (max-width: 1024px) {
      .grid {
        margin: 0;
      }
      .module {
        min-width: 60px;
      }
    }</code></pre>
    <p>La plantilla presenta una cuadrícula de enlaces de nombre de héroe.</p>
    <ul>
      <li>Define una propiedad de matriz heroes</li>
      <li>El constructor espera que Angular inyecte HeroService en una propiedad privada heroService</li>
      <li>El ciclo vital ngOnInit() llama al gancho getHeroes().</li>
    </ul>
    <p>Este getHeroes() devuelve la lista dividida de héroes en las posiciones 1 y 5, devolviendo solo cuatro de los mejores héroes (2 °, 3 °, 4 ° y 5 °).</p>
    <ol type="1" start="6">
      <li>Agregar la ruta del tablero:</li>
    </ol>
    <p>Importa el tablero dentro del archivo app-routing.module.ts</p>
    <pre><code id="target70"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target70"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { DashboardComponent }   from './dashboard/dashboard.component';</code></pre>
    <p>Agrege una ruta:</p>
    <pre><code id="target71"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target71"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>{ path: 'dashboard', component: DashboardComponent },</code></pre>
    <ol type="1" start="7">
      <li>Agregar una ruta predeterminada:</li>
    </ol>
    <p>Cuando se inicia la aplicación, la barra de direcciones del navegador apunta a la raíz del sitio web. Eso no coincide con ninguna ruta existente, por lo que el enrutador no navega por ningún lado. El espacio debajo del está en blanco.&lt;router-outlet>. Para que la aplicación navegue al tablero automáticamente, agregue la siguiente ruta a la AppRoutingModule.Routes.</p>
    <pre><code id="target72"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target72"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>{ path: '', redirectTo: '/dashboard', pathMatch: 'full' },</code></pre>
    <p>Esta ruta redirige una URL que coincide completamente con la ruta vacía a la ruta cuya ruta es '/dashboard. Después de que el navegador se actualiza, el enrutador carga el DashboardComponent y la barra de direcciones del navegador muestra la URL /dashboard.</p>
    <ol type="1" start="8">
      <li>Agregar un enlace para el tablero:</li>
    </ol>
    <p>El usuario debe poder navegar hacia adelante y hacia atrás entre DashboardComponent y HeroesComponent haciendo clic en los enlaces en el área de navegación cerca de la parte superior de la página. Agrega un enlace de navegación del tablero a la plantilla AppComponent justo arriba del enlace Héroes</p>
    <pre><code id="target73"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target73"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h1>{{title}}&lt;h1>
    &lt;nav>
      &lt;a routerLink="/dashboard">Dashboard&lt;a>
      &lt;a routerLink="/heroes">Heroes&lt;a>
    &lt;nav>
    &lt;router-outlet>&lt;router-outlet>
    &lt;app-messages>&lt;app-messages></code></pre>
    <ol type="1" start="8">
      <li>Navegando a los detalles del héroe:</li>
    </ol>
    <p>La heroDetailsComponent muestra detalles de un héroe seleccionado. El usuario podrá acceder de tres formas diferentes a los detalles:</p>
    <ul>
      <li>Al hacer click en un héroe en el tablero</li>
      <li>Al hacer click en un héroe en la lista de héroes</li>
      <li>Al pegar una URL en la barra de direcciones que identifique al héroe a mostrar</li>
    </ul>
    <ol type="1" start="9">
      <li>Eliminar detalles del héroe del HeroesComponent:</li>
    </ol>
    <p>Cuando el usuario hace click en un elemento de héroe en el HeroesComponent, la aplicación debe navegar hacia el HeroDetailComponent, reemplazando la vista de lista de héroes con la vista de detalles de héroe. La vista de lista de héroes ya no debería mostrar detalles de héroes como lo hace ahora.<br/>Abre la plantilla HeroesComponent ( heroes/heroes.component.html) y elimina el elemento &lt;app-hero-detail> de la parte inferior.<br/>Ahora al hacer click en un elemento de héroe ahora no hace nada. Lo arreglaremos después de habilitar el enrutamiento a HeroDetailComponent.</p>
    <ol type="1" start="10">
      <li>Agregar la ruta de detalles de héreo:</li>
    </ol>
    <p>En primer lugar abriremos el archivo app-routing.module.ts e importaremos el HeroDetailComponent</p>
    <pre><code id="target74"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target74"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { HeroDetailComponent }  from './hero-detail/hero-detail.component';</code></pre>
    <p>Luego agrega una ruta parametrizada en la que le pasemos el id del héreo del que vamos a ver los detalles</p>
    <pre><code id="target75"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target75"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>{ path: 'detail/:id', component: HeroDetailComponent },</code></pre>
    <p>Los dos puntos (:) indican que es una marcador de posición para un héreo especificada por su id.<br/>Llegados a este punto nuestras rutas deberían de estar así:</p>
    <pre><code id="target76"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target76"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>const routes: Routes = [
      { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
      { path: 'dashboard', component: DashboardComponent },
      { path: 'detail/:id', component: HeroDetailComponent },
      { path: 'heroes', component: HeroesComponent }
    ];</code></pre>
    <ol type="1" start="11">
      <li>Dar funcionalidad a los enlaces de la DashboardComponent:</li>
    </ol>
    <p>Ahora mismo nuestros enlaces del DashboardComponent no hacen nada. Ahora que ya hemos colocado la ruta en el enrutador vamos a arreglar los enlaces para poder navegar a través de la ruta parametrizada del tablero. Abre el archivo dashboard.component.html y modifique el código para que quede de la siguiente manera:</p>
    <pre><code id="target77"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target77"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;a *ngFor="let hero of heroes" class="col-1-4"
          routerLink="/detail/{{hero.id}}">
        &lt;div class="module hero">
          &lt;h4>{{hero.name}}&lt;h4>
        &lt;div>
      &lt;a></code></pre>
<p>Está utilizando el enlace de interpolación Angular dentro del repetidor para insertar las iteraciones actuales en cada uno con .*ngForhero.idrouter</p>
<ol type="1" start="12">
  <li>Dar funcionalidad a los enlaces de la HeroesComponent:</li>
</ol>
<p>Los elementos de héroe en el HeroesComponentson son elementos &lt;li> cuyos eventos de click están vinculados al método onSelect() del componente. Así que abre el archivo  heroes.component.html y modificalo para que el código quede de la siguiente manera:</p>
<pre><code id="target78"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target78"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;ul class="heroes">
      &lt;li *ngFor="let hero of heroes"
        &lt;a routerLink="/detail/{{hero.id}}">
        &lt;span class="badge">{{hero.id}}&lt;span> {{hero.name}}
      &lt;li>
    &lt;ul></code></pre>
<p>Por último modifica el heroes.component.css para que se vea de forma correcta:</p>
<pre><code id="target79"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target79"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* AppComponent's private CSS styles */
      h1 {
        font-size: 1.2em;
        margin-bottom: 0;
      }
      h2 {
        font-size: 2em;
        margin-top: 0;
        padding-top: 0;
      }
      nav a {
        padding: 5px 10px;
        text-decoration: none;
        margin-top: 10px;
        display: inline-block;
        background-color: #eee;
        border-radius: 4px;
      }
      nav a:visited, a:link {
        color: #334953;
      }
      nav a:hover {
        color: #039be5;
        background-color: #cfd8dc;
      }
      nav a.active {
        color: #039be5;
      }</code></pre>
  <ol type="1" start="13">
    <li>Enrutar el HeroDetailComponent:</li>
  </ol>
  <p>Antes el padre HeroesComponent configuraba la propiedad HeroDetailComponent.hero y el HeroDetailComponent mostraba al héroe. Ahora HeroesComponent ya no hace eso, ahora el enrutador crea HeroDetailComponent en respuesta a una URL parametrizada.<br/>Ahora el HeroDetailComponent necesita una nueva forma de obtener el héroe y para ello necesitaremos:</p>
  <ul>
    <li>Obtener la ruta que la creó</li>
    <li>Extraer el id de la ruta</li>
    <li>Adquirir el héroe con ese id y desde el servidor a través del HeroService</li>
  </ul>
  <p>Para ella agrega las siguientes importaciones dentro del archivo hhero-detail.component.ts</p>
  <pre><code id="target80"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target80"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { ActivatedRoute } from '@angular/router';
      import { Location } from '@angular/common';
      import { HeroService }  from '../hero.service';</code></pre>
<p>E inyecta lo siguientes servicios dentro del constructor:</p>
<pre><code id="target81"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target81"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>constructor(
        private route: ActivatedRoute,
        private heroService: HeroService,
        private location: Location
      ) {}</code></pre>
<p>El ActivedRoute guarda información sobre la ruta a esta instancia del HeroDetailComponent. Este componente está interesado en los parámetros de la ruta extraídos de la URL. El parámetro "id" es el id del héroe a mostrar. La HeroService obtiene datos desde el servidor remoto y este componente los usa para conseguir el héroe a mostrar por la pantalla. El location es un servicio Angular para interactuar con el navegador.</p>
<ol type="1" start="14">
  <li>Extraer el id para el párametro de la ruta:</li>
</ol>
<p>Ahora debemos definir el ngOnInit() y el getHero() de la siguiente forma:</p>
<pre><code id="target82"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target82"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ngOnInit(): void {
        this.getHero();
      }

      getHero(): void {
        const id = +this.route.snapshot.paramMap.get('id');
        this.heroService.getHero(id)
          .subscribe(hero => this.hero = hero);
      }</code></pre>
<p>El navegador se actualizará y la aplicación se bloqueará con un error del compilador. HeroService no tiene un método getHero(). Lo añadinermos ahora.</p>
<ol type="1" start="15">
  <li>Agregar HeroService.getHero():</li>
</ol>
<p>Abre el hero.service.ts y agrega el siguiente método:</p>
<pre><code id="target83"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target83"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHero(id: number): Observable&lt;Hero> {
        // TODO: send the message _after_ fetching the hero
        this.messageService.add(`HeroService: fetched hero id=${id}`);
        return of(HEROES.find(hero => hero.id === id));
      }</code></pre>
<ol type="1" start="16">
  <li>Encontrar el camino de regreso:</li>
</ol>
<p>Al hacer click en el botón de retroceso del navegador, puedes volver a la lista de héroes o a la vista del panel, dependiendo de cuál lo envió a la vista de detalles. Sería bueno tener un botón en la vista HeroDetail que pueda hacer eso. Agrega un botón de retroceso en la parte inferior de la plantilla del componente y enlácelo al método goBack() del componente.<br/>Abre el archivo hero-detail.compoent.html y añade:</p>
<pre><code id="target84"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target84"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;button (click)="goBack()">go back&lt;button></code></pre>
<p>Agrega un método goBack() a la clase de componente que navegue hacia atrás un paso en la pila de historial del navegador utilizando el Locationservicio que inyectó anteriormente dentro del archivo hero-detail.component.ts.</p>
<pre><code id="target85"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target85"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>goBack(): void {
        this.location.back();
      }</code></pre>
<p>Actualiza el navegador y comprueba todos los cambios.</p>
    </div>
  </section>

  <!-- HTTP -->
  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="http">
    <div class="w-100">
      <h2 class="text-primary">HTTP</h2>
    <p>En esta última parte del tutorial vamos a agregar las siguientes caracteristicas: </p>
    <ul>
      <li>Obtener datos del héroe con solicitudes HTTP</li>
      <li>Permitir a los usuarios agregar, editar y eliminar héroes y guardos estos cambios a través de HTTP</li>
      <li>Permitir a los usuarios buscar héroes por nombre</li>
    </ul>
    <ol type="1" start="1">
      <li>Habilitar servicios HTTP:</li>
    </ol>
    <p>HttpClient es el mecanismo de Angular para comunicarse con un servidor remoto a través de HTTP. Tenemos que hacer que este disponible en cualquier lugar de la aplicación en dos pasos. En primer lugar, lo agregaremos a la raíz importando el módulo: (Importalo dentro del archivo app.module.ts)</p>
    <pre><code id="target86"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target86"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { HttpClientModule }    from '@angular/common/http';</code></pre>
    <p>A continuación, dentro del mismo archivo añade el siguiente trozo de código:</p>
    <pre><code id="target87"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target87"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>@NgModule({
      imports: [
        HttpClientModule,
      ],
    })</code></pre>
    <ol type="1" start="2">
      <li>Simular un servidor de datos:</li>
    </ol>
    <p>En este momento no disponemos de un servidor real, para poder imitar ese comportamiento instalaremos un módulo a la que se le realizará solicitudes y recibirá respuestas de una API web que se encuentra en memoria.</p>
    <ol type="I" start="1">
      <li>Instalar el paquete de API desde la consula con el siguiente comando:</li>
    </ol>
    <pre><code id="target88"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target88"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>npm install angular-in-memory-web-api --save</code></pre>
    <ol type="I" start="2">
      <li>Importar la clase dentro del archivo app.module.ts:</li>
    </ol>
    <pre><code id="target89"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target89"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
      import { InMemoryDataService }  from './in-memory-data.service';</code></pre>
      <ol type="I" start="3">
        <li>Agregar la matriz y configurarla dentro del app.module.ts:</li>
      </ol>
    <pre><code id="target90"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target90"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>HttpClientModule,

      // The HttpClientInMemoryWebApiModule module intercepts HTTP requests
      // and returns simulated server responses.
      // Remove it when a real server is ready to receive requests.
      HttpClientInMemoryWebApiModule.forRoot(
        InMemoryDataService, { dataEncapsulation: false }
      )</code></pre>
    <p>El método de configuración toma una clase que prepara la base de datos en memoria.forRoot()InMemoryDataService</p>
    <ol type="I" start="4">
      <li>Generar la clase con el siguiente comando:</li>
    </ol>
    <pre><code id="target91"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target91"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate service InMemoryData</code></pre>
    <ol type="I" start="5">
      <li>Reemplace el contenido predeterminado del archivo in-memory-data.service.ts por el siguiente contenido:</li>
    </ol>
    <pre><code id="target92"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target92"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { InMemoryDbService } from 'angular-in-memory-web-api';
      import { Hero } from './hero';
      import { Injectable } from '@angular/core';
      
      @Injectable({
        providedIn: 'root',
      })
      export class InMemoryDataService implements InMemoryDbService {
        createDb() {
          const heroes = [
            { id: 11, name: 'Dr Nice' },
            { id: 12, name: 'Narco' },
            { id: 13, name: 'Bombasto' },
            { id: 14, name: 'Celeritas' },
            { id: 15, name: 'Magneta' },
            { id: 16, name: 'RubberMan' },
            { id: 17, name: 'Dynama' },
            { id: 18, name: 'Dr IQ' },
            { id: 19, name: 'Magma' },
            { id: 20, name: 'Tornado' }
          ];
          return {heroes};
        }
      
        // Overrides the genId method to ensure that a hero always has an id.
        // If the heroes array is empty,
        // the method below returns the initial number (11).
        // if the heroes array is not empty, the method below returns the highest
        // hero id + 1.
        genId(heroes: Hero[]): number {
          return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;
        }
      }</code></pre>
      <ol type="1" start="3">
        <li>Héroes y HTTP:</li>
      </ol>
      <p>En primer lugar abre el archivo hero.service.ts e importe el siguiente código:</p>
      <pre><code id="target93"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target93"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { HttpClient, HttpHeaders } from '@angular/common/http';</code></pre>
      <p>Inyecta en el mismo archivo el constructor con una propiedad privada llamada HeroServiceHttpClienthhtp</p>
      <pre><code id="target94"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target94"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>constructor(
        private http: HttpClient,
        private messageService: MessageService) { }</code></pre>
      <p>Ahora envolveremos el método para poder llamarlo con frecuencia</p>
      <pre><code id="target95"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target95"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** Log a HeroService message with the MessageService */
        private log(message: string) {
          this.messageService.add(`HeroService: ${message}`);
        }</code></pre>
      <p>Por último define el formulario con la dirección del recurso héroes del servidor.</p>
      <pre><code id="target96"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target96"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>private heroesUrl = 'api/heroes';  // URL to web api</code></pre>
      <ol type="1" start="4">
        <li>Conseguir héroes con HttpClient:</li>
      </ol>
      <p>La corriente utiliza la función RxJS para devolver una matriz de héroes ficticios como un archivo .HeroService.getHeroes()of()Observable&lt;Hero[]>, ahora modifica el siguiente trozo de código:</p>
      <pre><code id="target97"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target97"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes(): Observable&lt;Hero[]> {
        return of(HEROES);
      }</code></pre>
      <p>Y modificalo para usarlo del a siguiente manera:</p>
      <pre><code id="target98"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target98"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** GET heroes from the server */
        getHeroes (): Observable&lt;Hero[]> {
          return this.http.get&lt;Hero[]>(this.heroesUrl)
        }</code></pre>
    <p>Actualiza el explorador. Los datos del héroe deben cargarse correctamente desde el servidor ficticio.</p>
    <ol type="1" start="5">
      <li>Manejo de errores:</li>
    </ol>
    <p>Las cosas van mal, especialmente cuando se obtienen datos de un servidor remoto. El método debe detectar errores y hacer algo para resolverlos. Importe el siguiente código dentro del archivo hero.service.ts</p>
    <pre><code id="target99"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target99"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { catchError, map, tap } from 'rxjs/operators';</code></pre>
    <p>Ahora extienda el resultado con el método:</p>
    <pre><code id="target100"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target100"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>getHeroes (): Observable&lt;Hero[]> {
  return this.http.get&lt;Hero[]>(this.heroesUrl)
    .pipe(
      catchError(this.handleError&lt;Hero[]>('getHeroes', []))
    );
}</code></pre>
<p>El operador intercepta un Observable que falló. Pasa el error un controlador de errores que puede hacer lo que quiere con el error. El método siguiente notifica el error y, a continuación, devuelve un resultado inocuo para que la aplicación siga funcionando<br/>Añade el siguiente código para qye en lugar de controlar errores directamente, devuelvan una función de controlador de errores que se ha configurado con el nombre de la operación que ha fallado:</p>
<pre><code id="target101"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target101"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/**
  * Handle Http operation that failed.
  * Let the app continue.
  * @param operation - name of the operation that failed
  * @param result - optional value to return as the observable result
  */
 private handleError&lt;T> (operation = 'operation', result?: T) {
   return (error: any): Observable&lt;T> => {
 
     // TODO: send the error to remote logging infrastructure
     console.error(error); // log to console instead
 
     // TODO: better job of transforming error for user consumption
     this.log(`${operation} failed: ${error.message}`);
 
     // Let the app keep running by returning an empty result.
     return of(result as T);
   };
 }</code></pre>
 <ol type="1" start="6">
  <li>Aproveche el Observable:</li>
</ol>
<p>Los métodos aprovecharán el flujo de valores observables y enviarán un mensaje, a través del método, al área de mensaje en la parte inferior de la página. Lo harán con el operador RxJS, que examina los valores observables, hace algo con esos valores y los pasa. La devolución de llamada no toca los valores en sí. Aquí está la versión final:</p>
<pre><code id="target102"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target102"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** GET heroes from the server */
  getHeroes (): Observable&lt;Hero[]> {
    return this.http.get&lt;Hero[]>(this.heroesUrl)
      .pipe(
        tap(_ => this.log('fetched heroes')),
        catchError(this.handleError&lt;Hero[]>('getHeroes', []))
      );
  }</code></pre>
  <ol type="1" start="7">
    <li>Obtener héroe por Id:</li>
  </ol>
  <p>La mayoria de las API web admiten solicitudes con el id, por eso vamos a actualizar el método para poder realizar la petición a través de su Id para recurperar la información</p>
  <pre><code id="target103"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target103"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** GET hero by id. Will 404 if id not found */
    getHero(id: number): Observable&lt;Hero> {
      const url = `${this.heroesUrl}/${id}`;
      return this.http.get&lt;Hero>(url).pipe(
        tap(_ => this.log(`fetched hero id=${id}`)),
        catchError(this.handleError&lt;Hero>(`getHero id=${id}`))
      );
    }</code></pre>
    <p>Tenemos dos diferencias significativas con respecto al getHeroes()</p>
    <ul>
      <li>getHero() construye una URL de solicitud con el identificador del héroe deseado.</li>
      <li>El servidor ahora responde con un único héroe</li>
    </ul>
    <ol type="1" start="8">
      <li>Actualizar Héroers:</li>
    </ol>
    <p>En este putno nuestra intención es poder editar el nombre de un héroe desde su vista detalle, y que a medida que vayas escribiendo también se actualice el titulo del héroe que tenemos en la parte superior de la página. Para ello vamos a añadir un botón de guardar al final de la plantilla (hero-detail.component.html)</p>
    <pre><code id="target103"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target103"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;button (click)="save()">save&lt;button></code></pre>
    <p>Ahora en la clase del componente (hero-detail.component.ts) agrega el siguiente método para conservar los cambios del nombre</p>
    <pre><code id="target104"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target104"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>save(): void {
      this.heroService.updateHero(this.hero)
        .subscribe(() => this.goBack());
    }</code></pre>
    <ul>
      <li>Añadir HeroService.updateHero():</li>
    </ul>
    <p>Ahora dentro del archivo hero.service.ts debemos de añadir el método para conservar el héroe cambiado en el servidor. Agrega el siguiente código:</p>
    <pre><code id="target105"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target105"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** PUT: update the hero on the server */
      updateHero (hero: Hero): Observable&lt;any> {
        return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
          tap(_ => this.log(`updated hero id=${hero.id}`)),
          catchError(this.handleError&lt;any>('updateHero'))
        );
      }</code></pre>
    <p>La API espera un encabezado especial para los solicitudes de guardado HTTP para definirla nos iremos al archivo hero.servide.ts y añadiremos el siguiente código:</p>
    <pre><code id="target106"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target106"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' })
    };</code></pre>
    <ol type="1" start="9">
      <li>Añadir nuevos Héroers:</li>
    </ol>
    <p>Para añadir nuevos héroes solo necesitamos un formulario para añadirlos. Para ello en la plantilla heroes.component.html añadiremos el siguiente fragmento de código:</p>
    <pre><code id="target107"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target107"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div>
      &lt;label>Hero name:
        &lt;input #heroName />
      &lt;/label>
      &lt;!-- (click) passes input value to add() and then clears the input -->
      &lt;button (click)="add(heroName.value); heroName.value=''">
            add
      &lt;button>
    &lt;div></code></pre>
<p>Ahora debemos poner una resputa para el evento click, para ello dentro del heroes.component.ts añadiremos el siguiente fragmento de código:</p>
<pre><code id="target108"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target108"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>add(name: string): void {
      name = name.trim();
      if (!name) { return; }
      this.heroService.addHero({ name } as Hero)
        .subscribe(hero => {
          this.heroes.push(hero);
        });
    }</code></pre>
<p>Cuando el nombre no esta vacio, el controlador crea un nuevo objeto y lo pasa al método services.HeroIdAddHero(). Cuando el héroe se guarda correctamente la llamada recibe el nuevo héroe y lo instar en la lista para que pueda ser visto. Para ello dentro del hero.service.ts añade el siguiente código:</p>
<pre><code id="target109"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target109"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** POST: add a new hero to the server */
      addHero (hero: Hero): Observable&lt;Hero> {
        return this.http.post&lt;Hero>(this.heroesUrl, hero, this.httpOptions).pipe(
          tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),
          catchError(this.handleError&lt;Hero>('addHero'))
        );
      }</code></pre>
  <ol type="1" start="10">
    <li>Eliminar Héroers:</li>
  </ol>
  <p>Ahora debemos de añadir un botón al lado de cada héroe para que pueda ser eliminado. Lo primero es añadir ese botón dentro del heroes.component.html, agregalo justo después del &lt;a>  routerLink="/detail/{{hero.id}}">
    &lt;span class="badge">{{hero.id}}&lt;span> {{hero.name}}
  &lt;/a> </p>
  <pre><code id="target110"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target110"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;button class="delete" title="delete hero"
    (click)="delete(hero)">x&lt;/button></code></pre>
  <p>Ahora agregaremos CSS para que el botón se vea de forma correcta dentro de la lista, para ello dentro del heroes.component.css sustituye el CSS por el siguiente: </p>
  <pre><code id="target111"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target111"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* HeroesComponent's private CSS styles */
    .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
    }
    .heroes li {
      position: relative;
      cursor: pointer;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    
    .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
    }
    
    .heroes a {
      color: #333;
      text-decoration: none;
      position: relative;
      display: block;
      width: 250px;
    }
    
    .heroes a:hover {
      color:#607D8B;
    }
    
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color:#405061;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      min-width: 16px;
      text-align: right;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
    
    button {
      background-color: #eee;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      cursor: hand;
      font-family: Arial;
    }
    
    button:hover {
      background-color: #cfd8dc;
    }
    
    button.delete {
      position: relative;
      left: 194px;
      top: -32px;
      background-color: gray !important;
      color: white;
    }</code></pre>
    <p>Ahora debemos de agregar el controlador a la clase del componente delete(), por ello dentro del heroes.component.ts añade:</p>
    <pre><code id="target112"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target112"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>delete(hero: Hero): void {
      this.heroes = this.heroes.filter(h => h !== hero);
      this.heroService.deleteHero(hero).subscribe();
    }</code></pre>
    <p>Aunque el componente delega la eliminación de héroes en el , sigue siendo responsable de actualizar su propia lista de héroes. El método del componente elimina inmediatamente el héroe a eliminar de esa lista, anticipando que el se realizará correctamente en el servidor <br/> Ahora en el hero.service.ts añada el siguiente código:</p>
    <pre><code id="target113"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target113"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/** DELETE: delete the hero from the server */
      deleteHero (hero: Hero | number): Observable&lt;Hero> {
        const id = typeof hero === 'number' ? hero : hero.id;
        const url = `${this.heroesUrl}/${id}`;
      
        return this.http.delete&lt;Hero>(url, this.httpOptions).pipe(
          tap(_ => this.log(`deleted hero id=${id}`)),
          catchError(this.handleError&lt;Hero>('deleteHero'))
        );
      }</code></pre>
      <ol type="1" start="11">
        <li>Buscar héroers por su nombre:</li>
      </ol>
      <p>En este último ejercicio, aprenderemos a encadenar operadores para poder minimizar el número de solicitudes HTTP similares y consumir el ancho de banda de red de forma económica.<br/>En primer lugar necesitaremos agregar un método al archivo hero.service.ts</p>
      <pre><code id="target114"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target114"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* GET heroes whose name contains search term */
        searchHeroes(term: string): Observable&lt;Hero[]> {
          if (!term.trim()) {
            // if not search term, return empty hero array.
            return of([]);
          }
          return this.http.get&lt;Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(
            tap(_ => this.log(`found heroes matching "${term}"`)),
            catchError(this.handleError&lt;Hero[]>('searchHeroes', []))
          );
        }</code></pre>
        <p>Este método nos devolverá una matriz con los resultados encontrados, o vacia en caso de no tener ningún resultado.<br/>Ahora necesitamos agegar en la plantilla dashboard.component.html un elemento de busqueda:</p>
        <pre><code id="target115"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target115"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;h3>Top Heroes&lt;/h3>
      &lt;div class="grid grid-pad">
      &lt;a *ngFor="let hero of heroes" class="col-1-4"
          routerLink="/detail/{{hero.id}}">
        &lt;div class="module hero">
        &lt;h4>{{hero.name}}&lt;h4>
        &lt;div>
      &lt;a>
      &lt;div>
                
      &lt;app-hero-search>&lt;/app-hero-search></code></pre>
<p>Para que esto funcione necesitaremos tener un componente llamado app-hero-search y para ello dentro de la consola ejecutaremos el siguiente comando para crearlo:</p>
<pre><code id="target116"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target116"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>ng generate component hero-search</code></pre>
<p>En primer lugar dentro de la plantalla generada hero-search.component.html sustituiremos el código por el siguiente:</p>
<pre><code id="target117"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target117"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;div id="search-component">
        &lt;h4>&lt;label for="search-box">Hero Search&lt;label>&lt;/4>

        &lt;input #searchBox id="search-box" (input)="search(searchBox.value)" />

      &lt;ul class="search-result">
        &lt;li *ngFor="let hero of heroes$ | async" >
        &lt;a routerLink="/detail/{{hero.id}}">
            {{hero.name}}
        &lt;a>
        &lt;li>
      &lt;ul>
      &lt;div></code></pre>
<p>Ahora agregaremos el CSS dentro del .hero-search.component.css necesario para que se vea bien:</p>
<pre><code id="target118"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target118"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>/* HeroSearch private styles */
      .search-result li {
        border-bottom: 1px solid gray;
        border-left: 1px solid gray;
        border-right: 1px solid gray;
        width: 195px;
        height: 16px;
        padding: 5px;
        background-color: white;
        cursor: pointer;
        list-style-type: none;
      }
      
      .search-result li:hover {
        background-color: #607D8B;
      }
      
      .search-result li a {
        color: #888;
        display: block;
        text-decoration: none;
      }
      
      .search-result li a:hover {
        color: white;
      }
      .search-result li a:active {
        color: white;
      }
      #search-box {
        width: 200px;
        height: 20px;
      }
      
      
      ul.search-result {
        margin-top: 0;
        padding-left: 0;
      }</code></pre>
  <p>Ahora es hora de modificar la clase generada, para ello dentro del hero-search.component.ts cambie el código por el siguiente:</p>
  <pre><code id="target119"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target119"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>import { Component, OnInit } from '@angular/core';

    import { Observable, Subject } from 'rxjs';
    
    import {
       debounceTime, distinctUntilChanged, switchMap
     } from 'rxjs/operators';
    
    import { Hero } from '../hero';
    import { HeroService } from '../hero.service';
    
    @Component({
      selector: 'app-hero-search',
      templateUrl: './hero-search.component.html',
      styleUrls: [ './hero-search.component.css' ]
    })
    export class HeroSearchComponent implements OnInit {
      heroes$: Observable&lt;Hero[]>;
      private searchTerms = new Subject&lt;string>();
    
      constructor(private heroService: HeroService) {}
    
      // Push a search term into the observable stream.
      search(term: string): void {
        this.searchTerms.next(term);
      }
    
      ngOnInit(): void {
        this.heroes$ = this.searchTerms.pipe(
          // wait 300ms after each keystroke before considering the term
          debounceTime(300),
    
          // ignore new term if same as previous term
          distinctUntilChanged(),
    
          // switch to new search observable each time the term changes
          switchMap((term: string) => this.heroService.searchHeroes(term)),
        );
      }
    }</code></pre>
    <p>Por último debemos definir serachTerms, para ello dentro del archivo anterior añadiremos al final el siguiente trozo de código:</p>
    <pre><code id="target120"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target120"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>private searchTerms = new Subject&lt;string>();

      // Push a search term into the observable stream.
      search(term: string): void {
        this.searchTerms.next(term);
      }</code></pre>
      <p>Para terminar debemos llamar al método desde la plantilla hero-search.component.html</p>
      <pre><code id="target121"> <button class="btn" data-clipboard-action="copy" data-clipboard-target="#target121"><img src="img/descargar.png" width="25px" height="25px" style="position: relative; right: 20px;"></button>&lt;input #searchBox id="search-box" (input)="search(searchBox.value)" /></code></pre>
      <p>Cada vez que el usuario escribe en el cuadro de texto, el enlace llama con el valor del cuadro de texto, un "término de búsqueda". Se convierte en un flujo constante de términos de búsqueda.<br/>Pasar un nuevo término de búsqueda directamente al después de cada pulsación de tecla de usuario crearía una cantidad excesiva de solicitudes HTTP, gravando los recursos del servidor y grabando a través de planes de datos. En su lugar, el método canaliza el observable a través de una secuencia de operadores RxJS que reducen el número de llamadas</p>

      <p><strong>Prueba tu aplicación, pues esté será el resultado final de nuestro tutorial</strong></p>
    </div>
  </section>

  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>
  <!--Script para el clipboard-->
  <script>new ClipboardJS('.btn');</script>
</body>

</html>
